{"version":3,"file":"sw.js","mappings":";;UAAA;UACA;;;;;WCDA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;ACNA;AACA,iBAAiB,SAAI,IAAI,SAAI;AAC7B,4BAA4B,+DAA+D,iBAAiB;AAC5G;AACA,oCAAoC,MAAM,+BAA+B,YAAY;AACrF,mCAAmC,MAAM,mCAAmC,YAAY;AACxF,gCAAgC;AAChC;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8CAA8C,oBAAoB;AAClE,KAAK;AACL;AACU","sources":["webpack://piper-browser-extension/webpack/bootstrap","webpack://piper-browser-extension/webpack/runtime/make namespace object","webpack://piper-browser-extension/./src/service-worker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/// <reference lib=\"webworker\" />\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n//On app update, besides switching cache bucket, we need to force browser to get the latest versions\n//from the network by also changing the query string of every resource\n//Otherwise our new cache bucket might get populated with old files from the browser cache (or\n//any intermediary network caches)\nconst myCache = {\n    'app-v16': [\n        '/?v=16',\n        '/index.html?v=16',\n        '/bundle.js?v=16',\n        '/inference-worker.js?v=16',\n    ],\n    'bootstrap-v1': [\n        '/bootstrap.min.css?v=1',\n    ],\n    'piper-phonemize-v1': [\n        '/piper_phonemize.js?v=1',\n        '/piper_phonemize.wasm?v=1',\n        '/piper_phonemize.data?v=1',\n    ],\n    'ort-1.17.3': [\n        'https://cdn.jsdelivr.net/npm/onnxruntime-web@1.17.3/dist/ort-wasm-simd-threaded.wasm',\n    ]\n};\nself.addEventListener('install', (event) => event.waitUntil(populateCache()));\nself.addEventListener('activate', (event) => event.waitUntil(removeOldCaches()));\nself.addEventListener('fetch', (event) => event.respondWith(handleFetch(event.request)));\nfunction populateCache() {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const key in myCache) {\n            if (!(yield caches.has(key))) {\n                const cache = yield caches.open(key);\n                yield cache.addAll(myCache[key]);\n            }\n        }\n    });\n}\nfunction removeOldCaches() {\n    return __awaiter(this, void 0, void 0, function* () {\n        for (const key of yield caches.keys()) {\n            if (!(key in myCache))\n                yield caches.delete(key);\n        }\n    });\n}\nfunction handleFetch(request) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (yield caches.match(request, { ignoreSearch: true })) || fetch(request);\n    });\n}\nexport {};\n"],"names":[],"sourceRoot":""}